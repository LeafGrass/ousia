diff --git a/platform/stm32/libmaple/usb/README b/platform/stm32/libmaple/usb/README
index 540b1ea..2c55364 100644
--- a/platform/stm32/libmaple/usb/README
+++ b/platform/stm32/libmaple/usb/README
@@ -2,36 +2,26 @@ The USB submodule of libmaple is responsible for:
 
     Initializing the USB peripheral, scaling the peripheral clocks
     appropriately, enabling the interrupt channels to USB, defining
-    the USB isr, resetting the USB disc pin (used to tell the host
+    the USB IRQ, resetting the USB DISC pin (used to tell the host
     were alive). Additionally, the USB submodule defines the virtual
-    com port USB applications that is available to all user sketches
-    via SerialUSB.print() and others.
+    COM port interface that is exposed to user sketches via SerialUSB.
 
 To use it:
 
-   [This section is out of date.  Does SerialUSB.begin() do the same
-   thing as the old Usb.init()?]
-
    SerialUSB.print/ln, available(), read(), write() implement the same
-     interface as Serial1/2/3
-
+   interface as Serial1/2/3.
 
 Current Status:
 
     Currently, the USB submodule relies on the low level core library
-    provided by ST to access the USB peripheral registers and
-    implement the USB transfer protocol for control endpoint
-    transfers.  The high level virtual com port application is
-    unfortunately hard to untangle from this low level dependence, and
-    when a new USB core library is written (to nix ST dependence)
+    provided by ST to implement the USB transfer protocol for control
+    endpoint transfers.  The high level virtual com port application
+    is unfortunately hard to untangle from this low level dependence,
+    and when a new USB core library is written (to nix ST dependence)
     changes will likely have to be made to virtual com application
     code. Ideally, the new core library should mimic the form of MyUSB
     (LUFA), since this library (USB for AVR) is growing in popularity
-    and in example applications. Additionally, the USB lib here relies
-    on low level hardware functions that were just ripped out of the
-    bootloader code (for simplicity) but clearly this should be
-    replaced with direct accesses to functions provided elsewhere in
-    libmaple.
+    and in example applications.
 
     The virtual com port serves two important purposes.
 
@@ -70,31 +60,13 @@ Current Status:
     be asserted (on Maple this is GPIO C12). Alternatively, the NVIC
     can be directly configured to disable the USB LP/HP IRQ's.
 
-    This library should exposed through usb.h; do not include any
-    other files direcly in your application.
-
     The files inside of usb_lib were provided by ST and are subject to
     their own license, all other files were written by the LeafLabs
     team and fall under the MIT license.
 
-Integration with libmaple:
-
-    The current USB lib is ported from the Maple bootloader code,
-    adapted to be a virtual com rather than a DFU device. That means
-    several functions are redefined locally that could have been
-    pulled from elsewhere in libmaple.  Thus, ths USB module doesn't
-    have too many dependencies on libmaple.  It even ensures that
-    clocks are configured correctly for its operation.  However, over
-    time, some libmaple dependencies have crept in.
-
 Todo:
 
     - write custom low level USB stack to strip out any remaining
       dependence on ST code
-    - remove dependence on hardware.c, since any functions here really
-      should have their own analogs elsewhere inside libmaple
     - add a high level USB application library that would allow users
       to make their own HID/Mass Storage/Audio/Video devices.
-    - implement a SerialUSB.link(SerialX) that forces a passthrough
-      the host computer virtual com to SerialX, and utilizes the
-      line_config commands correctly (sets baud etc)
diff --git a/platform/stm32/libmaple/usb/descriptors.c b/platform/stm32/libmaple/usb/descriptors.c
deleted file mode 100644
index a0bc046..0000000
--- a/platform/stm32/libmaple/usb/descriptors.c
+++ /dev/null
@@ -1,196 +0,0 @@
-/******************************************************************************
- * The MIT License
- *
- * Copyright (c) 2010 LeafLabs LLC.
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *****************************************************************************/
-
-#include "descriptors.h"
-#include "libmaple.h"
-#include "usb_config.h"
-
-const USB_Descriptor_Device usbVcomDescriptor_Device = {
- bLength:              sizeof(USB_Descriptor_Device),
- bDescriptorType:      USB_DESCRIPTOR_TYPE_DEVICE,
- bcdUSB:               0x0200,
- bDeviceClass:         USB_DEVICE_CLASS_CDC,
- bDeviceSubClass:      USB_DEVICE_SUBCLASS_CDC,
- bDeviceProtocol:      0x00,
- bMaxPacketSize0:      0x40,
- idVendor:             VCOM_ID_VENDOR,
- idProduct:            VCOM_ID_PRODUCT,
- bcdDevice:            0x0200,
- iManufacturer:        0x01,
- iProduct:             0x02,
- iSerialNumber:        0x00,
- bNumConfigurations:   0x01
-};
-
-const USB_Descriptor_Config usbVcomDescriptor_Config = {
- Config_Header: {
-   bLength:                   sizeof(USB_Descriptor_Config_Header),
-   bDescriptorType:           USB_DESCRIPTOR_TYPE_CONFIGURATION,
-   wTotalLength:              sizeof(USB_Descriptor_Config),
-   bNumInterfaces:            0x02,
-   bConfigurationValue:       0x01,
-   iConfiguration:            0x00,
-   bmAttributes:              (USB_CONFIG_ATTR_BUSPOWERED |
-                               USB_CONFIG_ATTR_SELF_POWERED),
-   bMaxPower:                 USB_CONFIG_MAX_POWER,
- },
-
- CCI_Interface:
-   {
-   bLength:                  sizeof(USB_Descriptor_Interface),
-   bDescriptorType:          USB_DESCRIPTOR_TYPE_INTERFACE,
-   bInterfaceNumber:         0x00,
-   bAlternateSetting:        0x00,
-   bNumEndpoints:            0x01,
-   bInterfaceClass:          USB_INTERFACE_CLASS_CDC,
-   bInterfaceSubClass:       USB_INTERFACE_SUBCLASS_CDC_ACM,
-   bInterfaceProtocol:       0x01, /* Common AT Commands */
-   iInterface:               0x00
-   },
-
- CDC_Functional_IntHeader:
-   {
-   bLength:                  CDC_FUNCTIONAL_DESCRIPTOR_SIZE(2),
-   bDescriptorType:          0x24,
-   SubType:                  0x00,
-   Data:                     {0x01, 0x10}
-   },
-
- CDC_Functional_CallManagement:
-   {
-   bLength:                  CDC_FUNCTIONAL_DESCRIPTOR_SIZE(2),
-   bDescriptorType:          0x24,
-   SubType:                  0x01,
-   Data:                     {0x03, 0x01}
-   },
-
- CDC_Functional_ACM:
-   {
-   bLength:                  CDC_FUNCTIONAL_DESCRIPTOR_SIZE(1),
-   bDescriptorType:          0x24,
-   SubType:                  0x02,
-   Data:                     {0x06}
-   },
-
- CDC_Functional_Union:
-   {
-   bLength:                  CDC_FUNCTIONAL_DESCRIPTOR_SIZE(2),
-   bDescriptorType:          0x24,
-   SubType:                  0x06,
-   Data:                     {0x00, 0x01}
-   },
-
- ManagementEndpoint:
-   {
-   bLength:                 sizeof(USB_Descriptor_Endpoint),
-   bDescriptorType:         USB_DESCRIPTOR_TYPE_ENDPOINT,
-   bEndpointAddress:        (USB_DESCRIPTOR_ENDPOINT_IN | VCOM_NOTIFICATION_EPNUM),
-   bmAttributes:            EP_TYPE_INTERRUPT,
-   wMaxPacketSize:          VCOM_NOTIFICATION_EPSIZE,
-   bInterval:               0xFF,
-   },
-
- DCI_Interface:
-   {
-   bLength:                sizeof(USB_Descriptor_Interface),
-   bDescriptorType:        USB_DESCRIPTOR_TYPE_INTERFACE,
-   bInterfaceNumber:       0x01,
-   bAlternateSetting:      0x00,
-   bNumEndpoints:          0x02,
-   bInterfaceClass:        USB_INTERFACE_CLASS_DIC,
-   bInterfaceSubClass:     0x00, /* None */
-   bInterfaceProtocol:     0x00, /* None */
-   iInterface:             0x00,
-   },
-
- DataOutEndpoint:
-   {
-   bLength:               sizeof(USB_Descriptor_Endpoint),
-   bDescriptorType:       USB_DESCRIPTOR_TYPE_ENDPOINT,
-   bEndpointAddress:      (USB_DESCRIPTOR_ENDPOINT_OUT | VCOM_RX_EPNUM),
-   bmAttributes:          EP_TYPE_BULK,
-   wMaxPacketSize:        VCOM_RX_EPSIZE,
-   bInterval:             0x00,
-   },
-
- DataInEndpoint:
-   {
-   bLength:               sizeof(USB_Descriptor_Endpoint),
-   bDescriptorType:       USB_DESCRIPTOR_TYPE_ENDPOINT,
-   bEndpointAddress:      (USB_DESCRIPTOR_ENDPOINT_IN | VCOM_TX_EPNUM),
-   bmAttributes:          EP_TYPE_BULK,
-   wMaxPacketSize:        VCOM_TX_EPSIZE,
-   bInterval:             0x00
-   }
-};
-
-/*****************************************************************************
- *****************************************************************************
- ***
- *** FIXME FIXME FIXME NOT THE RIGHT THING! MOVE ALL THIS INTO TO WIRISH!
- ***
- *****************************************************************************
- *****************************************************************************/
-
-const uint8 usbVcomDescriptor_LangID[USB_DESCRIPTOR_STRING_LEN(1)] = {
-    USB_DESCRIPTOR_STRING_LEN(1),
-    USB_DESCRIPTOR_TYPE_STRING,
-    0x09,
-    0x04
-};
-
-const uint8 usbVcomDescriptor_iManufacturer[USB_DESCRIPTOR_STRING_LEN(8)] = {
-    USB_DESCRIPTOR_STRING_LEN(8),
-    USB_DESCRIPTOR_TYPE_STRING,
-    'L', 0, 'e', 0, 'a', 0, 'f', 0,
-    'L', 0, 'a', 0, 'b', 0, 's', 0
-};
-
-/*
-  String Identifiers:
-
-  we may choose to specify any or none of the following string
-  identifiers:
-
-  iManufacturer:    LeafLabs
-  iProduct:         Maple R3
-  iSerialNumber:    NONE
-  iConfiguration:   NONE
-  iInterface(CCI):  NONE
-  iInterface(DCI):  NONE
-
-  additionally we must provide the unicode language identifier,
-  which is 0x0409 for US English
-*/
-const uint8 usbVcomDescriptor_iProduct[USB_DESCRIPTOR_STRING_LEN(8)] = {
-    USB_DESCRIPTOR_STRING_LEN(8),
-    USB_DESCRIPTOR_TYPE_STRING,
-    'M', 0, 'a', 0, 'p', 0, 'l', 0,
-    'e', 0, ' ', 0, ' ', 0, ' ', 0
-};
-
-/*****************************************************************************
- *****************************************************************************/
diff --git a/platform/stm32/libmaple/usb/descriptors.h b/platform/stm32/libmaple/usb/descriptors.h
index 13aef29..06d9ce7 100644
--- a/platform/stm32/libmaple/usb/descriptors.h
+++ b/platform/stm32/libmaple/usb/descriptors.h
@@ -25,9 +25,7 @@
 #ifndef __DESCRIPTORS_H
 #define __DESCRIPTORS_H
 
-
 #include "libmaple.h"
-#include "usb_lib.h"
 
 #define USB_DESCRIPTOR_TYPE_DEVICE        0x01
 #define USB_DESCRIPTOR_TYPE_CONFIGURATION 0x02
@@ -53,7 +51,6 @@
 
 #define USB_DESCRIPTOR_STRING_LEN(x) (2 + (x << 1))
 
-
 #if defined(__cplusplus)
 extern "C" {
 #endif
@@ -75,7 +72,6 @@ extern "C" {
     uint8 Data[DataSize];			\
   } __packed
 
-/* See http://www.beyondlogic.org/usbnutshell/usb5.shtml#DeviceDescriptors */
 typedef struct {
   uint8                 bLength;
   uint8                 bDescriptorType;
@@ -93,7 +89,6 @@ typedef struct {
   uint8                 bNumConfigurations;
 } __packed USB_Descriptor_Device;
 
-/* http://www.beyondlogic.org/usbnutshell/usb5.shtml#ConfigurationDescriptors */
 typedef struct {
   uint8                 bLength;
   uint8                 bDescriptorType;
@@ -105,7 +100,6 @@ typedef struct {
   uint8                 bMaxPower;
 } __packed USB_Descriptor_Config_Header;
 
-/* See http://www.beyondlogic.org/usbnutshell/usb5.shtml#InterfaceDescriptors */
 typedef struct {
   uint8                 bLength;
   uint8                 bDescriptorType;
@@ -155,7 +149,7 @@ extern const uint8 usbVcomDescriptor_iManufacturer[USB_DESCRIPTOR_STRING_LEN(8)]
 extern const uint8 usbVcomDescriptor_iProduct[USB_DESCRIPTOR_STRING_LEN(8)];
 
 #if defined(__cplusplus)
-  }
+}
 #endif
 
 #endif  // __DESCRIPTORS_H
diff --git a/platform/stm32/libmaple/usb/usb.c b/platform/stm32/libmaple/usb/usb.c
index a45a874..ec189d6 100644
--- a/platform/stm32/libmaple/usb/usb.c
+++ b/platform/stm32/libmaple/usb/usb.c
@@ -25,125 +25,97 @@
  *****************************************************************************/
 
 /**
- *  @brief usb-specific hardware setup, NVIC, clocks, and usb activities
- *  in the pre-attached state. includes some of the lower level callbacks
- *  needed by the usb library, like suspend,resume,init,etc
+ * @file usb.c
+ * @brief USB support.
  */
 
 #include "usb.h"
+
 #include "libmaple.h"
-//#include "usart.h" /* debug */
-#include "usb_lib.h"
 #include "gpio.h"
-#include "usb_hardware.h"
 #include "delay.h"
+#include "nvic.h"
+#include "rcc.h"
+
+#include "usb_reg_map.h"
+#include "usb_lib_globals.h"
+
+#include "usb_type.h"
+#include "usb_core.h"
 
-#include "usb_config.h"
-#include "usb_callbacks.h"
-#include "usb_lib.h"
-
-/* persistent usb structs */
-
-volatile uint32 bDeviceState = UNCONNECTED;
-volatile uint16 wIstr = 0;
-volatile uint32 bIntPackSOF = 0;
-
-DEVICE Device_Table =
-    {NUM_ENDPTS,
-     1};
-
-DEVICE_PROP Device_Property =
-    {usbInit,
-     usbReset,
-     usbStatusIn,
-     usbStatusOut,
-     usbDataSetup,
-     usbNoDataSetup,
-     usbGetInterfaceSetting,
-     usbGetDeviceDescriptor,
-     usbGetConfigDescriptor,
-     usbGetStringDescriptor,
-     0,
-     bMaxPacketSize};
-
-USER_STANDARD_REQUESTS User_Standard_Requests =
-    {NOP_Process,
-     usbSetConfiguration,
-     NOP_Process,
-     NOP_Process,
-     NOP_Process,
-     NOP_Process,
-     NOP_Process,
-     NOP_Process,
-     usbSetDeviceAddress};
-
-void (*pEpInt_IN[7])(void) =
-    {vcomDataTxCb,
-     vcomManagementCb,
-     NOP_Process,
-     NOP_Process,
-     NOP_Process,
-     NOP_Process,
-     NOP_Process};
-
-void (*pEpInt_OUT[7])(void) =
-    {NOP_Process,
-     NOP_Process,
-     vcomDataRxCb,
-     NOP_Process,
-     NOP_Process,
-     NOP_Process,
-     NOP_Process};
+static void dispatch_ctr_lp(void);
+
+/*
+ * usb_lib/ globals
+ */
+
+uint16 SaveTState;              /* caches TX status for later use */
+uint16 SaveRState;              /* caches RX status for later use */
+
+/*
+ * Other state
+ */
 
 struct {
   volatile RESUME_STATE eState;
   volatile uint8 bESOFcnt;
 } ResumeS;
 
-void setupUSB (void) {
-  gpio_set_mode(USB_DISC_DEV, USB_DISC_PIN, GPIO_OUTPUT_PP);
+static usblib_dev usblib = {
+    .irq_mask = USB_ISR_MSK,
+    .state = USB_UNCONNECTED,
+};
+usblib_dev *USBLIB = &usblib;
+
+/*
+ * Routines
+ */
 
-  /* setup the apb1 clock for USB */
-  pRCC->APB1ENR |= 0x00800000;
+void usb_init_usblib(void (**ep_int_in)(void), void (**ep_int_out)(void)) {
+    rcc_clk_enable(RCC_USB);
 
-  /* initialize the usb application */
-  gpio_write_bit(USB_DISC_DEV, USB_DISC_PIN, 0); // presents us to the host
-  USB_Init();  // low level init routine provided by the ST library
-}
+    USBLIB->ep_int_in = ep_int_in;
+    USBLIB->ep_int_out = ep_int_out;
+
+    /* usb_lib/ declares both and then assumes that pFoo points to Foo
+     * (even though the names don't always match), which is stupid for
+     * all of the obvious reasons, but whatever.  Here we are. */
+    pInformation = &Device_Info;
+    pProperty = &Device_Property;
+    pUser_Standard_Requests = &User_Standard_Requests;
 
-void disableUSB (void) {
-  // These are just guesses about how to do this
-  // TODO: real disable function
-  usbDsbISR();
-  gpio_write_bit(USB_DISC_DEV, USB_DISC_PIN, 1);
+    pInformation->ControlState = 2; /* FIXME [0.0.12] use
+                                       CONTROL_STATE enumerator */
+    pProperty->Init();
 }
 
 void usbSuspend(void) {
-  u16 wCNTR;
-  wCNTR = _GetCNTR();
-  wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
-  _SetCNTR(wCNTR);
+  uint16 cntr;
 
-  /* run any power reduction handlers */
-  bDeviceState = SUSPENDED;
+  /* TODO decide if read/modify/write is really what we want
+   * (e.g. usbResumeInit() reconfigures CNTR). */
+  cntr = USB_BASE->CNTR;
+  cntr |= USB_CNTR_FSUSP;
+  USB_BASE->CNTR = cntr;
+  cntr |= USB_CNTR_LP_MODE;
+  USB_BASE->CNTR = cntr;
+
+  USBLIB->state = USB_SUSPENDED;
 }
 
 void usbResumeInit(void) {
-  u16 wCNTR;
-
-  /* restart any clocks that had been stopped */
+  uint16 cntr;
 
-  wCNTR = _GetCNTR();
-  wCNTR &= (~CNTR_LPMODE);
-  _SetCNTR(wCNTR);
-
-  /* undo power reduction handlers here */
-  _SetCNTR(ISR_MSK);
+  cntr = USB_BASE->CNTR;
+  cntr &= ~USB_CNTR_LP_MODE;
+  USB_BASE->CNTR = cntr;
 
+  /* Enable interrupt lines */
+  USB_BASE->CNTR = USB_ISR_MSK;
 }
 
 void usbResume(RESUME_STATE eResumeSetVal) {
-  u16 wCNTR;
+  uint16 cntr;
 
   if (eResumeSetVal != RESUME_ESOF)
     ResumeS.eState = eResumeSetVal;
@@ -168,18 +140,18 @@ void usbResume(RESUME_STATE eResumeSetVal) {
         ResumeS.eState = RESUME_START;
       break;
     case RESUME_START:
-      wCNTR = _GetCNTR();
-      wCNTR |= CNTR_RESUME;
-      _SetCNTR(wCNTR);
+      cntr = USB_BASE->CNTR;
+      cntr |= USB_CNTR_RESUME;
+      USB_BASE->CNTR = cntr;
       ResumeS.eState = RESUME_ON;
       ResumeS.bESOFcnt = 10;
       break;
     case RESUME_ON:
       ResumeS.bESOFcnt--;
       if (ResumeS.bESOFcnt == 0) {
-          wCNTR = _GetCNTR();
-          wCNTR &= (~CNTR_RESUME);
-          _SetCNTR(wCNTR);
+          cntr = USB_BASE->CNTR;
+          cntr &= ~USB_CNTR_RESUME;
+          USB_BASE->CNTR = cntr;
           ResumeS.eState = RESUME_OFF;
       }
       break;
@@ -191,248 +163,218 @@ void usbResume(RESUME_STATE eResumeSetVal) {
     }
 }
 
-RESULT usbPowerOn(void) {
-  u16 wRegVal;
-
-  wRegVal = CNTR_FRES;
-  _SetCNTR(wRegVal);
-
-  wInterrupt_Mask = 0;
-  _SetCNTR(wInterrupt_Mask);
-  _SetISTR(0);
-  wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; // the bare minimum
-  _SetCNTR(wInterrupt_Mask);
-
-  return USB_SUCCESS;
-}
-
-RESULT usbPowerOff(void) {
-  _SetCNTR(CNTR_FRES);
-  _SetISTR(0);
-  _SetCNTR(CNTR_FRES + CNTR_PDWN);
-
-  /* note that all weve done here is powerdown the
-     usb peripheral. we have no disabled the clocks,
-     pulled the usb_disc pin back up, or reset the
-     application state machines */
-
-  return USB_SUCCESS;
-}
-
-
-// These two functions (usbEnbISR/usbDsbISR) are implementented in ST style,
-// and at least the DsbISR doesn't seem to work?
-void usbEnbISR(void) {
-  NVIC_InitTypeDef NVIC_InitStructure;
-  NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
-  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
-  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
-  NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
-  nvicInit(&NVIC_InitStructure);
-}
+#define SUSPEND_ENABLED 1
+void __irq_usb_lp_can_rx0(void) {
+  uint16 istr = USB_BASE->ISTR;
 
-void usbDsbISR(void) {
-  NVIC_InitTypeDef NVIC_InitStructure;
-  NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
-  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
-  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
-  NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
-  nvicInit(&NVIC_InitStructure);
-}
+  /* Use USB_ISR_MSK to only include code for bits we care about. */
 
-/* overloaded ISR routine, this is the main usb ISR */
-void __irq_usb_lp_can_rx0(void) {
-wIstr = _GetISTR();
-
-/* go nuts with the preproc switches since this is an ISTR and must be FAST */
-#if (ISR_MSK & ISTR_RESET)
-if (wIstr & ISTR_RESET & wInterrupt_Mask)
-  {
-    _SetISTR((u16)CLR_RESET);
-    Device_Property.Reset();
+#if (USB_ISR_MSK & USB_ISTR_RESET)
+  if (istr & USB_ISTR_RESET & USBLIB->irq_mask) {
+    USB_BASE->ISTR = ~USB_ISTR_RESET;
+    pProperty->Reset();
   }
 #endif
 
-
-#if (ISR_MSK & ISTR_DOVR)
-if (wIstr & ISTR_DOVR & wInterrupt_Mask)
-  {
-    _SetISTR((u16)CLR_DOVR);
+#if (USB_ISR_MSK & USB_ISTR_PMAOVR)
+  if (istr & ISTR_PMAOVR & USBLIB->irq_mask) {
+    USB_BASE->ISTR = ~USB_ISTR_PMAOVR;
   }
 #endif
 
-
-#if (ISR_MSK & ISTR_ERR)
-if (wIstr & ISTR_ERR & wInterrupt_Mask)
-  {
-    _SetISTR((u16)CLR_ERR);
+#if (USB_ISR_MSK & USB_ISTR_ERR)
+  if (istr & USB_ISTR_ERR & USBLIB->irq_mask) {
+    USB_BASE->ISTR = ~USB_ISTR_ERR;
   }
 #endif
 
-
-#if (ISR_MSK & ISTR_WKUP)
-if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
-    _SetISTR((u16)CLR_WKUP);
+#if (USB_ISR_MSK & USB_ISTR_WKUP)
+  if (istr & USB_ISTR_WKUP & USBLIB->irq_mask) {
+    USB_BASE->ISTR = ~USB_ISTR_WKUP;
     usbResume(RESUME_EXTERNAL);
-}
+  }
 #endif
 
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-#if (ISR_MSK & ISTR_SUSP)
-if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
+#if (USB_ISR_MSK & USB_ISTR_SUSP)
+  if (istr & USB_ISTR_SUSP & USBLIB->irq_mask) {
     /* check if SUSPEND is possible */
-    if (F_SUSPEND_ENABLED) {
+    if (SUSPEND_ENABLED) {
         usbSuspend();
     } else {
         /* if not possible then resume after xx ms */
         usbResume(RESUME_LATER);
     }
     /* clear of the ISTR bit must be done after setting of CNTR_FSUSP */
-    _SetISTR((u16)CLR_SUSP);
+    USB_BASE->ISTR = ~USB_ISTR_SUSP;
 }
 #endif
 
-
-#if (ISR_MSK & ISTR_SOF)
-if (wIstr & ISTR_SOF & wInterrupt_Mask) {
-    _SetISTR((u16)CLR_SOF);
-    bIntPackSOF++;
- }
+#if (USB_ISR_MSK & USB_ISTR_SOF)
+  if (istr & USB_ISTR_SOF & USBLIB->irq_mask) {
+    USB_BASE->ISTR = ~USB_ISTR_SOF;
+  }
 #endif
 
-
-#if (ISR_MSK & ISTR_ESOF)
-if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
-    _SetISTR((u16)CLR_ESOF);
+#if (USB_ISR_MSK & USB_ISTR_ESOF)
+  if (istr & USB_ISTR_ESOF & USBLIB->irq_mask) {
+    USB_BASE->ISTR = ~USB_ISTR_ESOF;
     /* resume handling timing is made with ESOFs */
     usbResume(RESUME_ESOF); /* request without change of the machine state */
- }
+  }
 #endif
 
-/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
-#if (ISR_MSK & ISTR_CTR)
-if (wIstr & ISTR_CTR & wInterrupt_Mask) {
-    /* servicing of the endpoint correct transfer interrupt */
-    /* clear of the CTR flag into the sub */
-    CTR_LP(); /* low priority ISR defined in the usb core lib */
- }
-#endif
+  /*
+   * Service the correct transfer interrupt.
+   */
 
+#if (USB_ISR_MSK & USB_ISTR_CTR)
+  if (istr & USB_ISTR_CTR & USBLIB->irq_mask) {
+    dispatch_ctr_lp();
+  }
+#endif
 }
 
+#define RESET_DELAY                     100000
 void usbWaitReset(void) {
   delay_us(RESET_DELAY);
-  systemHardReset();
-}
-
-/* This low-level send bytes function is NON-BLOCKING; blocking behavior, with
- * a timeout, is implemented in usercode (or in the Wirish C++ high level
- * implementation).
- *
- * This function will quickly copy up to 64 bytes of data (out of an
- * arbitrarily large buffer) into the USB peripheral TX buffer and return the
- * number placed in that buffer. It is up to usercode to divide larger packets
- * into 64-byte chunks to guarantee delivery.
- *
- *
- */
-void usbBlockingSendByte(char ch) {
-    while (countTx);
-    UserToPMABufferCopy((uint8*)&ch,VCOM_TX_ADDR,1);
-    _SetEPTxCount(VCOM_TX_ENDP,1);
-    _SetEPTxValid(VCOM_TX_ENDP);
-    countTx = 1;
-    while (countTx);
+  nvic_sys_reset();
 }
 
-uint32 usbSendBytes(const uint8* sendBuf, uint32 len) {
-  /* Last transmission hasn't finished, abort */
-  if (countTx) {
-    return 0;
-  }
-
-  // We can only put VCOM_TX_EPSIZE bytes in the buffer
-  if (len > VCOM_TX_EPSIZE / 2) {
-    len = VCOM_TX_EPSIZE / 2;
-  }
-
-  // Try to load some bytes if we can
-  if (len) {
-    UserToPMABufferCopy(sendBuf, VCOM_TX_ADDR, len);
-    _SetEPTxCount(VCOM_TX_ENDP, len);
-    countTx += len;
-    _SetEPTxValid(VCOM_TX_ENDP);
-  }
-
-  return len;
+uint8 usbIsConfigured() {
+  return USBLIB->state == USB_CONFIGURED;
 }
 
-/* returns the number of available bytes are in the recv FIFO */
-uint32 usbBytesAvailable(void) {
-  return newBytes;
+uint8 usbIsConnected() {
+  return USBLIB->state != USB_UNCONNECTED;
 }
 
-/* copies len bytes from the local recieve FIFO (not
-   usb packet buffer) into recvBuf and deq's the fifo.
-   will only copy the minimum of len or the available
-   bytes. returns the number of bytes copied */
-uint32 usbReceiveBytes(uint8* recvBuf, uint32 len) {
-  static int offset = 0;
+/*
+ * Auxiliary routines
+ */
 
-  if (len > newBytes) {
-      len = newBytes;
-  }
+static inline uint8 dispatch_endpt_zero(uint16 istr_dir);
+static inline void dispatch_endpt(uint8 ep);
+static inline void set_rx_tx_status0(uint16 rx, uint16 tx);
+
+static void handle_setup0(void);
+static void handle_in0(void);
+static void handle_out0(void);
+
+static void dispatch_ctr_lp() {
+    uint16 istr;
+    while (((istr = USB_BASE->ISTR) & USB_ISTR_CTR) != 0) {
+        /* TODO WTF, figure this out: RM0008 says CTR is read-only,
+         * but ST's firmware claims it's clear-only, and emphasizes
+         * the importance of clearing it in more than one place. */
+        USB_BASE->ISTR = ~USB_ISTR_CTR;
+        uint8 ep_id = istr & USB_ISTR_EP_ID;
+        if (ep_id == 0) {
+            /* TODO figure out why it's OK to break out of the loop
+             * once we're done serving endpoint zero, but not okay if
+             * there are multiple nonzero endpoint transfers to
+             * handle. */
+            if (dispatch_endpt_zero(istr & USB_ISTR_DIR))
+                return;
+        } else {
+            dispatch_endpt(ep_id);
+        }
+    }
+}
 
-  int i;
-  for (i=0;i<len;i++) {
-      recvBuf[i] = (uint8)(vcomBufferRx[i+offset]);
-  }
+/* FIXME Dataflow on endpoint 0 RX/TX status is based off of ST's
+ * code, and is ugly/confusing in its use of SaveRState/SaveTState.
+ * Fixing this requires filling in handle_in0(), handle_setup0(),
+ * handle_out0(). */
+static inline uint8 dispatch_endpt_zero(uint16 istr_dir) {
+    uint32 epr = (uint16)USB_BASE->EP[0];
 
-  newBytes -= len;
-  offset += len;
+    if (!(epr & (USB_EP_CTR_TX | USB_EP_SETUP | USB_EP_CTR_RX))) {
+        return 0;
+    }
 
-  /* re-enable the rx endpoint which we had set to receive 0 bytes */
-  if (newBytes == 0) {
-    SetEPRxCount(VCOM_RX_ENDP,VCOM_RX_EPSIZE);
-    SetEPRxStatus(VCOM_RX_ENDP,EP_RX_VALID);
-    offset = 0;
-  }
+    /* Cache RX/TX statuses in SaveRState/SaveTState, respectively.
+     * The various handle_foo0() may clobber these values
+     * before we reset them at the end of this routine. */
+    SaveRState = epr & USB_EP_STAT_RX;
+    SaveTState = epr & USB_EP_STAT_TX;
+
+    /* Set actual RX/TX statuses to NAK while we're thinking */
+    set_rx_tx_status0(USB_EP_STAT_RX_NAK, USB_EP_STAT_TX_NAK);
+
+    if (istr_dir == 0) {
+        /* ST RM0008: "If DIR bit=0, CTR_TX bit is set in the USB_EPnR
+         * register related to the interrupting endpoint.  The
+         * interrupting transaction is of IN type (data transmitted by
+         * the USB peripheral to the host PC)." */
+        ASSERT_FAULT(epr & USB_EP_CTR_TX);
+        usb_clear_ctr_tx(USB_EP0);
+        handle_in0();
+    } else {
+        /* RM0008: "If DIR bit=1, CTR_RX bit or both CTR_TX/CTR_RX
+         * are set in the USB_EPnR register related to the
+         * interrupting endpoint. The interrupting transaction is of
+         * OUT type (data received by the USB peripheral from the host
+         * PC) or two pending transactions are waiting to be
+         * processed."
+         *
+         * [mbolivar] Note how the following control flow (which
+         * replicates ST's) doesn't seem to actually handle both
+         * interrupts that are ostensibly pending when both CTR_RX and
+         * CTR_TX are set.
+         *
+         * TODO sort this mess out.
+         */
+        if (epr & USB_EP_CTR_TX) {
+            usb_clear_ctr_tx(USB_EP0);
+            handle_in0();
+        } else {                /* SETUP or CTR_RX */
+            /* SETUP is held constant while CTR_RX is set, so clear it
+             * either way */
+            usb_clear_ctr_rx(USB_EP0);
+            if (epr & USB_EP_SETUP) {
+                handle_setup0();
+            } else {            /* CTR_RX */
+                handle_out0();
+            }
+        }
+    }
 
-  return len;
+    set_rx_tx_status0(SaveRState, SaveTState);
+    return 1;
 }
 
-void usbSendHello(void) {
-  uint8 bufin = 48 + recvBufIn;;
-  uint8 bufout = 48 + recvBufOut;
-  uint8 avail  = 48 + usbBytesAvailable();
-
-  char *line = "\r\n";
-  while(usbSendBytes(&bufin,1) == 0);
-  while(usbSendBytes(&bufout,1) == 0);
-  while(usbSendBytes(&avail,1) == 0);
-  while(usbSendBytes((uint8*)line,2) == 0);
-
-  uint8 recv[64];
-  usbReceiveBytes(&recv[0],1);
+static inline void dispatch_endpt(uint8 ep) {
+    uint32 epr = USB_BASE->EP[ep];
+    /* If ISTR_CTR is set and the ISTR gave us this EP_ID to handle,
+     * then presumably at least one of CTR_RX and CTR_TX is set, but
+     * again, ST's control flow allows for the possibility of neither.
+     *
+     * TODO try to find out if neither being set is possible. */
+    if (epr & USB_EP_CTR_RX) {
+        usb_clear_ctr_rx(ep);
+        (USBLIB->ep_int_out[ep - 1])();
+    }
+    if (epr & USB_EP_CTR_TX) {
+        usb_clear_ctr_tx(ep);
+        (USBLIB->ep_int_in[ep - 1])();
+    }
 }
 
-uint8 usbGetDTR() {
-  return ((line_dtr_rts & CONTROL_LINE_DTR) != 0);
+static inline void set_rx_tx_status0(uint16 rx, uint16 tx) {
+    usb_set_ep_rx_stat(USB_EP0, rx);
+    usb_set_ep_tx_stat(USB_EP0, tx);
 }
 
-uint8 usbGetRTS() {
-  return ((line_dtr_rts & CONTROL_LINE_RTS) != 0);
-}
+/* TODO Rip out usb_lib/ dependency from the following functions: */
 
-uint8 usbIsConfigured() {
-  return (bDeviceState == CONFIGURED);
+static void handle_setup0(void) {
+    Setup0_Process();
 }
 
-uint8 usbIsConnected() {
-  return (bDeviceState != UNCONNECTED);
+static void handle_in0(void) {
+    In0_Process();
 }
 
-uint16 usbGetPending() {
-  return countTx;
+static void handle_out0(void) {
+    Out0_Process();
 }
-
diff --git a/platform/stm32/libmaple/usb/usb.h b/platform/stm32/libmaple/usb/usb.h
index c724c54..107ea77 100644
--- a/platform/stm32/libmaple/usb/usb.h
+++ b/platform/stm32/libmaple/usb/usb.h
@@ -27,13 +27,41 @@
 #ifndef _USB_H_
 #define _USB_H_
 
-#include "usb_lib.h"
-#include "libmaple.h"
+#include "libmaple_types.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+#ifndef USB_ISR_MSK
+/* Handle CTRM, WKUPM, SUSPM, ERRM, SOFM, ESOFM, RESETM */
+#define USB_ISR_MSK 0xBF00
+#endif
+
+typedef enum usb_dev_state {
+    USB_UNCONNECTED,
+    USB_ATTACHED,
+    USB_POWERED,
+    USB_SUSPENDED,
+    USB_ADDRESSED,
+    USB_CONFIGURED
+} usb_dev_state;
+
+/* Encapsulates global state formerly handled by usb_lib/
+ * functionality */
+typedef struct usblib_dev {
+    uint32 irq_mask;
+    void (**ep_int_in)(void);
+    void (**ep_int_out)(void);
+    usb_dev_state state;
+} usblib_dev;
+
+extern usblib_dev *USBLIB;
+
+/*
+ * Convenience routines, etc.
+ */
+
 typedef enum {
     RESUME_EXTERNAL,
     RESUME_INTERNAL,
@@ -45,45 +73,18 @@ typedef enum {
     RESUME_ESOF
 } RESUME_STATE;
 
-typedef enum {
-    UNCONNECTED,
-    ATTACHED,
-    POWERED,
-    SUSPENDED,
-    ADDRESSED,
-    CONFIGURED
-} DEVICE_STATE;
-
-extern volatile uint32 bDeviceState;
+void usb_init_usblib(void (**ep_int_in)(void), void (**ep_int_out)(void));
 
-void setupUSB(void);
-void disableUSB(void);
 void usbSuspend(void);
 void usbResumeInit(void);
 void usbResume(RESUME_STATE);
 
-RESULT usbPowerOn(void);
-RESULT usbPowerOff(void);
-
-void usbDsbISR(void);
-void usbEnbISR(void);
-
 /* overloaded ISR routine, this is the main usb ISR */
 void __irq_usb_lp_can_rx0(void);
 void usbWaitReset(void);
 
-/* blocking functions for send/receive */
-void   usbBlockingSendByte(char ch);
-uint32 usbSendBytes(const uint8* sendBuf,uint32 len);
-uint32 usbBytesAvailable(void);
-uint32 usbReceiveBytes(uint8* recvBuf, uint32 len);
-uint8 usbGetDTR(void);
-uint8 usbGetRTS(void);
 uint8 usbIsConnected(void);
 uint8 usbIsConfigured(void);
-uint16 usbGetPending(void);
-
-void usbSendHello(void);
 
 #ifdef __cplusplus
 } // extern "C"
diff --git a/platform/stm32/libmaple/usb/usb_callbacks.c b/platform/stm32/libmaple/usb/usb_callbacks.c
deleted file mode 100644
index 890a97f..0000000
--- a/platform/stm32/libmaple/usb/usb_callbacks.c
+++ /dev/null
@@ -1,332 +0,0 @@
-/* insert license */
-
-#include "usb_callbacks.h"
-#include "usb_lib.h"
-#include "descriptors.h"
-#include "usb_config.h"
-#include "usb.h"
-#include "usb_hardware.h"
-
-ONE_DESCRIPTOR Device_Descriptor = {
-    (uint8*)&usbVcomDescriptor_Device,
-    sizeof(USB_Descriptor_Device)
-};
-
-ONE_DESCRIPTOR Config_Descriptor = {
-    (uint8*)&usbVcomDescriptor_Config,
-    sizeof(USB_Descriptor_Config)
-};
-
-ONE_DESCRIPTOR String_Descriptor[3] = {
-    {(uint8*)&usbVcomDescriptor_LangID,       USB_DESCRIPTOR_STRING_LEN(1)},
-    {(uint8*)&usbVcomDescriptor_iManufacturer,USB_DESCRIPTOR_STRING_LEN(8)},
-    {(uint8*)&usbVcomDescriptor_iProduct,     USB_DESCRIPTOR_STRING_LEN(8)}
-};
-
-uint8 last_request = 0;
-
-USB_Line_Coding line_coding = {
- bitrate:     115200,
- format:      0x00, /* stop bits-1 */
- paritytype:  0x00,
- datatype:    0x08
-};
-
-uint8 vcomBufferRx[VCOM_RX_BUFLEN];
-volatile uint32 countTx    = 0;
-volatile uint32 recvBufIn  = 0;
-volatile uint32 recvBufOut = 0;
-volatile uint32 maxNewBytes   = VCOM_RX_BUFLEN;
-volatile uint32 newBytes = 0;
-RESET_STATE reset_state = DTR_UNSET;
-uint8       line_dtr_rts = 0;
-
-void vcomDataTxCb(void) {
-    /* do whatever after data has been sent to host */
-
-    /* allows usbSendBytes to stop blocking */
-
-    /* assumes tx transactions are atomic 64 bytes (nearly certain they are) */
-    countTx = 0;
-}
-
-/* we could get arbitrarily complicated here for speed purposes
-   however, the simple scheme here is to implement a receive fifo
-   and always set the maximum to new bytes to the space remaining
-   in the fifo. this number will be reincremented after calls
-   to usbReceiveBytes */
-void vcomDataRxCb(void) {
-  /* do whatever after data has been received from host */
-
-  /* setEPRxCount on the previous cycle should garuntee
-     we havnt received more bytes than we can fit */
-  newBytes = GetEPRxCount(VCOM_RX_ENDP);
-  SetEPRxStatus(VCOM_RX_ENDP,EP_RX_NAK);
-
-  /* todo, not checking very carefully for edge cases. USUALLY,
-     if we emit the reset pulse and send 4 bytes, then newBytes
-     should be 4. But its POSSIBLE that this would be violated
-     in some cases */
-
-  /* magic number, {0x31, 0x45, 0x41, 0x46} is "1EAF" */
-  uint8 chkBuf[4];
-  uint8 cmpBuf[4] = {0x31, 0x45, 0x41, 0x46};
-  if (reset_state == DTR_NEGEDGE) {
-    reset_state = DTR_LOW;
-
-    if  (newBytes >= 4) {
-      unsigned int target = (unsigned int)usbWaitReset | 0x1;
-
-      PMAToUserBufferCopy(chkBuf,VCOM_RX_ADDR,4);
-
-      int i;
-      USB_Bool cmpMatch = TRUE;
-      for (i=0; i<4; i++) {
-          if (chkBuf[i] != cmpBuf[i]) {
-              cmpMatch = FALSE;
-          }
-      }
-
-      if (cmpMatch) {
-          asm volatile("mov r0, %[stack_top]      \n\t"             // Reset the stack
-                       "mov sp, r0                \n\t"
-                       "mov r0, #1                \n\t"
-                       "mov r1, %[target_addr]    \n\t"
-                       "mov r2, %[cpsr]           \n\t"
-                       "push {r2}                 \n\t"             // Fake xPSR
-                       "push {r1}                 \n\t"             // Target address for PC
-                       "push {r0}                 \n\t"             // Fake LR
-                       "push {r0}                 \n\t"             // Fake R12
-                       "push {r0}                 \n\t"             // Fake R3
-                       "push {r0}                 \n\t"             // Fake R2
-                       "push {r0}                 \n\t"             // Fake R1
-                       "push {r0}                 \n\t"             // Fake R0
-                       "mov lr, %[exc_return]     \n\t"
-                       "bx lr"
-                       :
-                       : [stack_top] "r" (STACK_TOP),
-                         [target_addr] "r" (target),
-                         [exc_return] "r" (EXC_RETURN),
-                         [cpsr] "r" (DEFAULT_CPSR)
-                       : "r0", "r1", "r2");
-          /* should never get here */
-      }
-    }
-  }
-
-  PMAToUserBufferCopy(&vcomBufferRx[0],VCOM_RX_ADDR,newBytes);
-}
-
-void vcomManagementCb(void) {
-    /* unused. This enpoint would callback if we had sent a linestate
-       changed notification */
-}
-
-u8* vcomGetSetLineCoding(uint16 length) {
-    if (length == 0) {
-        pInformation->Ctrl_Info.Usb_wLength = sizeof(USB_Line_Coding);
-    }
-    return (uint8*)&line_coding;
-}
-
-void vcomSetLineState(void) {
-}
-
-void usbInit(void) {
-    pInformation->Current_Configuration = 0;
-    usbPowerOn();
-
-    _SetISTR(0);
-    wInterrupt_Mask = ISR_MSK;
-    _SetCNTR(wInterrupt_Mask);
-
-    usbEnbISR();
-    bDeviceState = UNCONNECTED;
-}
-
-void usbReset(void) {
-    pInformation->Current_Configuration = 0;
-
-    /* current feature is current bmAttributes */
-    pInformation->Current_Feature = (USB_CONFIG_ATTR_BUSPOWERED | USB_CONFIG_ATTR_SELF_POWERED);
-
-    _SetBTABLE(USB_BTABLE_ADDRESS);
-
-    /* setup control endpoint 0 */
-    _SetEPType(ENDP0, EP_CONTROL);
-    _SetEPTxStatus(ENDP0, EP_TX_STALL);
-    _SetEPRxAddr(ENDP0,VCOM_CTRL_RX_ADDR);
-    _SetEPTxAddr(ENDP0,VCOM_CTRL_TX_ADDR);
-    Clear_Status_Out(ENDP0);
-
-    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
-    SetEPRxValid(ENDP0);
-
-    /* setup management endpoint 1  */
-    SetEPType     (VCOM_NOTIFICATION_ENDP,     EP_INTERRUPT);
-    SetEPTxAddr   (VCOM_NOTIFICATION_ENDP,     VCOM_NOTIFICATION_ADDR);
-    SetEPTxStatus (VCOM_NOTIFICATION_ENDP,     EP_TX_NAK);
-    SetEPRxStatus (VCOM_NOTIFICATION_ENDP,     EP_RX_DIS);
-
-    /* setup data endpoint OUT (rx) */
-    /*   SetEPType     (VCOM_RX_ENDP, EP_BULK); */
-    /*   SetEPRxAddr   (VCOM_RX_ENDP, VCOM_RX_ADDR); */
-    /*   SetEPRxCount  (VCOM_RX_ENDP, VCOM_RX_EPSIZE); */
-    /*   // SetEPTxStatus (VCOM_RX_ENDP, EP_TX_DIS); */
-    /*   SetEPRxStatus (VCOM_RX_ENDP, EP_RX_VALID); */
-
-    SetEPType     (3, EP_BULK);
-    SetEPRxAddr   (3, 0x110);
-    SetEPRxCount  (3,64);
-    // SetEPTxStatus (VCOM_RX_ENDP, EP_TX_DIS);
-    SetEPRxStatus (3, EP_RX_VALID);
-
-    /* setup data endpoint IN (tx)  */
-    SetEPType     (VCOM_TX_ENDP, EP_BULK);
-    SetEPTxAddr   (VCOM_TX_ENDP, VCOM_TX_ADDR);
-    SetEPTxStatus (VCOM_TX_ENDP, EP_TX_NAK);
-    SetEPRxStatus (VCOM_TX_ENDP, EP_RX_DIS);
-
-    bDeviceState = ATTACHED;
-    SetDeviceAddress(0);
-
-    /* reset the rx fifo */
-    recvBufIn   = 0;
-    recvBufOut  = 0;
-    maxNewBytes = VCOM_RX_EPSIZE;
-    countTx     = 0;
-}
-
-
-void usbStatusIn(void) {
-    /* adjust the usart line coding
-       if we wish to couple the CDC line coding
-       with the real usart port */
-}
-
-void usbStatusOut(void) {
-}
-
-RESULT usbDataSetup(uint8 request) {
-    uint8 *(*CopyRoutine)(uint16);
-    CopyRoutine = NULL;
-
-    if (Type_Recipient == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
-        switch (request) {
-        case (GET_LINE_CODING):
-            CopyRoutine = vcomGetSetLineCoding;
-            last_request = GET_LINE_CODING;
-            break;
-        case (SET_LINE_CODING):
-            CopyRoutine = vcomGetSetLineCoding;
-            last_request = SET_LINE_CODING;
-            break;
-        default: break;
-        }
-    }
-
-    if (CopyRoutine == NULL) {
-        return USB_UNSUPPORT;
-    }
-
-    pInformation->Ctrl_Info.CopyData = CopyRoutine;
-    pInformation->Ctrl_Info.Usb_wOffset = 0;
-    (*CopyRoutine)(0);
-    return USB_SUCCESS;
-}
-
-RESULT usbNoDataSetup(u8 request) {
-    uint8 new_signal;
-
-    /* we support set com feature but dont handle it */
-    if (Type_Recipient == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
-
-        switch (request) {
-        case (SET_COMM_FEATURE):
-            return USB_SUCCESS;
-        case (SET_CONTROL_LINE_STATE):
-            /* to reset the board, pull both dtr and rts low
-               then pulse dtr by itself */
-            new_signal = pInformation->USBwValues.bw.bb0 & (CONTROL_LINE_DTR | CONTROL_LINE_RTS);
-            line_dtr_rts = new_signal & 0x03;
-
-            switch (reset_state) {
-                /* no default, covered enum */
-            case DTR_UNSET:
-                if ((new_signal & CONTROL_LINE_DTR) == 0 ) {
-                    reset_state = DTR_LOW;
-                } else {
-                    reset_state = DTR_HIGH;
-                }
-                break;
-
-            case DTR_HIGH:
-                if ((new_signal & CONTROL_LINE_DTR) == 0 ) {
-                    reset_state = DTR_NEGEDGE;
-                } else {
-                    reset_state = DTR_HIGH;
-                }
-                break;
-
-            case DTR_NEGEDGE:
-                if ((new_signal & CONTROL_LINE_DTR) == 0 ) {
-                    reset_state = DTR_LOW;
-                } else {
-                    reset_state = DTR_HIGH;
-                }
-                break;
-
-            case DTR_LOW:
-                if ((new_signal & CONTROL_LINE_DTR) == 0 ) {
-                    reset_state = DTR_LOW;
-                } else {
-                    reset_state = DTR_HIGH;
-                }
-                break;
-            }
-
-            return USB_SUCCESS;
-        }
-    }
-    return USB_UNSUPPORT;
-}
-
-RESULT usbGetInterfaceSetting(uint8 interface, uint8 alt_setting) {
-    if (alt_setting > 0) {
-        return USB_UNSUPPORT;
-    } else if (interface > 1) {
-        return USB_UNSUPPORT;
-    }
-
-    return USB_SUCCESS;
-}
-
-
-u8* usbGetDeviceDescriptor(u16 length) {
-    return Standard_GetDescriptorData(length, &Device_Descriptor);
-}
-
-u8* usbGetConfigDescriptor(u16 length) {
-    return Standard_GetDescriptorData(length, &Config_Descriptor);
-}
-
-u8* usbGetStringDescriptor(u16 length) {
-    uint8 wValue0 = pInformation->USBwValue0;
-
-    if (wValue0 > 2) {
-        return NULL;
-    }
-    return Standard_GetDescriptorData(length, &String_Descriptor[wValue0]);
-}
-
-/* internal callbacks to respond to standard requests */
-void usbSetConfiguration(void) {
-    if (pInformation->Current_Configuration != 0) {
-        bDeviceState = CONFIGURED;
-    }
-}
-
-void usbSetDeviceAddress(void) {
-    bDeviceState = ADDRESSED;
-}
-
diff --git a/platform/stm32/libmaple/usb/usb_callbacks.h b/platform/stm32/libmaple/usb/usb_callbacks.h
deleted file mode 100644
index 20d2c13..0000000
--- a/platform/stm32/libmaple/usb/usb_callbacks.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/* insert license */
-
-#ifndef __USB_CALLBACKS
-#define __USB_CALLBACKS
-
-#include "libmaple.h"
-#include "usb_lib.h"
-#include "usb_config.h"
-
-#define SET_LINE_CODING        0x20
-#define GET_LINE_CODING        0x21
-#define SET_COMM_FEATURE       0x02
-#define SET_CONTROL_LINE_STATE 0x22
-#define CONTROL_LINE_DTR       (0x01)
-#define CONTROL_LINE_RTS       (0x02)
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-typedef struct {
-  uint32 bitrate;
-  uint8  format;
-  uint8  paritytype;
-  uint8  datatype;
-} USB_Line_Coding;
-
-typedef enum {
-  DTR_UNSET,
-  DTR_HIGH,
-  DTR_NEGEDGE,
-  DTR_LOW  
-} RESET_STATE;
-
-extern RESET_STATE reset_state;  /* tracks DTR/RTS */
-extern uint8       line_dtr_rts;  
-extern volatile uint32 countTx;
-extern uint8 vcomBufferRx[VCOM_RX_BUFLEN];  /* no reason this has to be VCOM_RX_EPSIZE, could be bigger */
-extern volatile uint32 recvBufIn;   /* the FIFO in index to the recvbuffer */
-extern volatile uint32 recvBufOut;  /* the FIFO out index to the recvbuffer */
-extern volatile uint32 maxNewBytes;
-extern volatile uint32 newBytes;
-
-void vcomDataTxCb(void);
-void vcomDataRxCb(void);
-void vcomManagementCb(void);
-
-uint8* vcomGetSetLineCoding(uint16 length);
-void vcomSetLineSate(void);
-
-void usbInit(void);
-/* internal functions (as per the usb_core pProperty structure) */
-void usbInit(void);
-void usbReset(void);
-void usbStatusIn(void);
-void usbStatusOut(void);
-
-RESULT usbDataSetup(uint8 request);
-RESULT usbNoDataSetup(uint8 request);
-RESULT usbGetInterfaceSetting(uint8,uint8);
-
-uint8* usbGetDeviceDescriptor(uint16 length);
-uint8* usbGetConfigDescriptor(uint16 length);
-uint8* usbGetStringDescriptor(uint16 length);
-
-/* internal callbacks to respond to standard requests */
-void usbSetConfiguration(void);
-void usbSetDeviceAddress(void);
-
-#if defined(__cplusplus)
-}
-#endif
-
-
-#endif
diff --git a/platform/stm32/libmaple/usb/usb_config.h b/platform/stm32/libmaple/usb/usb_config.h
deleted file mode 100644
index eee64a3..0000000
--- a/platform/stm32/libmaple/usb/usb_config.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/* insert license */
-
-#ifndef __USB_CONFIG_H
-#define __USB_CONFIG_H
-
-#include "usb_lib.h"
-#include "gpio.h"
-
-/******************************************************************************
- ******************************************************************************
- ***
- ***   HACK ALERT
- ***
- ***   FIXME FIXME FIXME FIXME
- ***
- ***   A bunch of board-specific #defines that are only used by the
- ***   USB routines got put into libmaple.h for what appear to be
- ***   historical reasons.  I'm [mbolivar] putting them in here for
- ***   now, so that we can treat the usb/ directory as a black box,
- ***   freeing the rest of libmaple/ to be implemented as a
- ***   general-purpose STM32 library. All of this REALLY needs to get
- ***   moved into wirish when we get a chance to redo the USB stack.
- ***
- ******************************************************************************
- *****************************************************************************/
-
-#define VCOM_ID_VENDOR            0x1EAF
-#define RESET_DELAY               (100000)
-#define USB_CONFIG_MAX_POWER      (100 >> 1)
-
-#if defined(BOARD_leach) || defined(BOARD_leach_high)
-
-	#define VCOM_ID_PRODUCT      0x0004
-	#define USB_DISC_DEV         GPIOC
-	#define USB_DISC_PIN         12
-
-#elif defined(BOARD_maple) || defined(BOARD_maple_RET6)
-
-    /* USB Identifier numbers */
-    #define VCOM_ID_PRODUCT      0x0004
-    #define USB_DISC_DEV         GPIOC
-    #define USB_DISC_PIN         12
-
-#elif defined(BOARD_maple_mini)
-
-    #define VCOM_ID_PRODUCT      0x0004
-    #define USB_DISC_DEV         GPIOB
-    #define USB_DISC_PIN         9
-
-#elif defined(BOARD_maple_native)
-
-    #define VCOM_ID_PRODUCT      0x0004
-    #define USB_DISC_DEV         GPIOB
-    #define USB_DISC_PIN         8
-
-#else
-
-#error ("Sorry! the USB stack relies on LeafLabs board-specific "       \
-        "configuration right now.  If you want, you can pretend you're one " \
-        "of our boards; i.e., #define BOARD_maple, BOARD_maple_mini, or " \
-        "BOARD_maple_native according to what matches your MCU best. "  \
-        "You should also take a look at libmaple/usb/descriptors.c; we make " \
-        "some assumptions there that you probably won't like.")
-
-#endif
-
-/******************************************************************************
- ******************************************************************************
- ***
- ***   END HACK
- ***
- ******************************************************************************
- *****************************************************************************/
-
-
-/* choose addresses to give endpoints the max 64 byte buffers */
-#define USB_BTABLE_ADDRESS        0x00
-#define VCOM_CTRL_EPNUM           0x00
-#define VCOM_CTRL_RX_ADDR         0x40
-#define VCOM_CTRL_TX_ADDR         0x80
-#define VCOM_CTRL_EPSIZE          0x40
-
-#define VCOM_TX_ENDP              ENDP1
-#define VCOM_TX_EPNUM             0x01
-#define VCOM_TX_ADDR              0xC0
-#define VCOM_TX_EPSIZE            0x40
-
-#define VCOM_NOTIFICATION_ENDP    ENDP2
-#define VCOM_NOTIFICATION_EPNUM   0x02
-#define VCOM_NOTIFICATION_ADDR    0x100
-#define VCOM_NOTIFICATION_EPSIZE  0x40
-
-#define VCOM_RX_ENDP              ENDP3
-#define VCOM_RX_EPNUM             0x03
-#define VCOM_RX_ADDR              0x110
-#define VCOM_RX_EPSIZE            0x40
-#define VCOM_RX_BUFLEN            (VCOM_RX_EPSIZE*3)
-
-#define bMaxPacketSize            0x40  /* 64B, maximum for USB FS Devices */
-
-#define NUM_ENDPTS                0x04
-
-/* handle all usb interrupts */
-#define ISR_MSK (CNTR_CTRM    |                                         \
-                 CNTR_WKUPM   |                                         \
-                 CNTR_SUSPM   |                                         \
-                 CNTR_ERRM    |                                         \
-                 CNTR_SOFM    |                                         \
-                 CNTR_ESOFM   |                                         \
-                 CNTR_RESETM)
-
-#define F_SUSPEND_ENABLED 1
-
-
-#endif
diff --git a/platform/stm32/libmaple/usb/usb_hardware.c b/platform/stm32/libmaple/usb/usb_hardware.c
deleted file mode 100644
index 9a7d12c..0000000
--- a/platform/stm32/libmaple/usb/usb_hardware.c
+++ /dev/null
@@ -1,99 +0,0 @@
-/******************************************************************************
- * The MIT License
- *
- * Copyright (c) 2010 LeafLabs LLC.
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation
- * files (the "Software"), to deal in the Software without
- * restriction, including without limitation the rights to use, copy,
- * modify, merge, publish, distribute, sublicense, and/or sell copies
- * of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *****************************************************************************/
-
-/**
- *  @file usb_hardware.c
- *
- *  @brief init routines to setup clocks and interrupts for usb.
- *
- */
-
-#include "usb_hardware.h"
-
-void nvicInit(NVIC_InitTypeDef* NVIC_InitStruct) {
-    u32 tmppriority = 0x00;
-    u32 tmpreg      = 0x00;
-    u32 tmpmask     = 0x00;
-    u32 tmppre      = 0;
-    u32 tmpsub      = 0x0F;
-
-    SCB_TypeDef* rSCB = (SCB_TypeDef *) SCB_BASE;
-    NVIC_TypeDef* rNVIC = (NVIC_TypeDef *) NVIC_BASE;
-
-
-    /* Compute the Corresponding IRQ Priority -------------------------------*/
-    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700))>> 0x08;
-    tmppre = (0x4 - tmppriority);
-    tmpsub = tmpsub >> tmppriority;
-
-    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority <<
-        tmppre;
-    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
-
-    tmppriority = tmppriority << 0x04;
-    tmppriority = ((u32)tmppriority) <<
-        ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
-
-    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
-    tmpmask = (u32)0xFF <<
-        ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
-    tmpreg &= ~tmpmask;
-    tmppriority &= tmpmask;
-    tmpreg |= tmppriority;
-
-    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
-
-    /* Enable the Selected IRQ Channels -------------------------------------*/
-    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
-        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
-}
-
-void nvicDisableInterrupts() {
-    NVIC_TypeDef* rNVIC = (NVIC_TypeDef *) NVIC_BASE;
-    rNVIC->ICER[0] = 0xFFFFFFFF;
-    rNVIC->ICER[1] = 0xFFFFFFFF;
-    rNVIC->ICPR[0] = 0xFFFFFFFF;
-    rNVIC->ICPR[1] = 0xFFFFFFFF;
-
-    /* Disable the systick timer, which operates separately from NVIC */
-    SET_REG(STK_CTRL,0x04);
-}
-
-void systemHardReset(void) {
-    SCB_TypeDef* rSCB = (SCB_TypeDef *) SCB_BASE;
-    typedef void (*funcPtr)(void);
-
-    /* Reset */
-    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
-
-    /* Should never get here */
-    while (1) {
-        asm volatile("nop");
-    }
-}
-
-
-
diff --git a/platform/stm32/libmaple/usb/usb_hardware.h b/platform/stm32/libmaple/usb/usb_hardware.h
deleted file mode 100644
index 205967b..0000000
--- a/platform/stm32/libmaple/usb/usb_hardware.h
+++ /dev/null
@@ -1,138 +0,0 @@
-/* *****************************************************************************
- * The MIT License
- *
- * Copyright (c) 2010 LeafLabs LLC.
- *
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
- * THE SOFTWARE.
- * ****************************************************************************/
-
-#include "rcc.h"
-#include "usb_type.h"
-
-#ifndef _USB_HARDWARE_H_
-#define _USB_HARDWARE_H_
-
-/* macro'd register and peripheral definitions */
-#define EXC_RETURN 0xFFFFFFF9
-#define DEFAULT_CPSR 0x61000000
-
-#define FLASH ((u32)0x40022000)
-
-#define USB_PACKET_BUFFER ((u32)0x40006000)
-
-#define SCS_BASE   ((u32)0xE000E000)
-#ifndef NVIC_BASE /* avoid redefinition in nvic.h */
-#define NVIC_BASE  (SCS_BASE + 0x0100)
-#endif
-#define SCB_BASE   (SCS_BASE + 0x0D00)
-
-#define SCS      0xE000E000
-#define NVIC     (SCS+0x100)
-#define SCB      (SCS+0xD00)
-#define STK      (SCS+0x10)
-
-#define SCB_VTOR (SCB+0x08)
-#define STK_CTRL (STK+0x00)
-
-#define USB_HP_IRQ  ((u8)0x13)
-#define USB_LP_IRQ  ((u8)0x14)
-
-/* AIRCR  */
-#define AIRCR_RESET         0x05FA0000
-#define AIRCR_RESET_REQ     (AIRCR_RESET | (u32)0x04);
-
-/* temporary copyage of example from kiel */
-#define __VAL(__TIMCLK, __PERIOD) ((__TIMCLK/1000000UL)*__PERIOD)
-#define __PSC(__TIMCLK, __PERIOD)  (((__VAL(__TIMCLK, __PERIOD)+49999UL)/50000UL) - 1)
-#define __ARR(__TIMCLK, __PERIOD) ((__VAL(__TIMCLK, __PERIOD)/(__PSC(__TIMCLK, __PERIOD)+1)) - 1)
-
-#define SET_REG(addr,val)  do { *(vu32*)(addr)=val; } while (0)
-#define GET_REG(addr)      do { *(vu32*)(addr); } while (0)
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-/* todo: there must be some major misunderstanding in how we access regs. The direct access approach (GET_REG)
-   causes the usb init to fail upon trying to activate RCC_APB1 |= 0x00800000. However, using the struct approach
-   from ST, it works fine...temporarily switching to that approach */
-typedef struct
-{
-  vu32 CR;
-  vu32 CFGR;
-  vu32 CIR;
-  vu32 APB2RSTR;
-  vu32 APB1RSTR;
-  vu32 AHBENR;
-  vu32 APB2ENR;
-  vu32 APB1ENR;
-  vu32 BDCR;
-  vu32 CSR;
-} RCC_RegStruct;
-#define pRCC ((RCC_RegStruct *) RCC_BASE)
-
-typedef struct {
-  vu32 ISER[2];
-  u32  RESERVED0[30];
-  vu32 ICER[2];
-  u32  RSERVED1[30];
-  vu32 ISPR[2];
-  u32  RESERVED2[30];
-  vu32 ICPR[2];
-  u32  RESERVED3[30];
-  vu32 IABR[2];
-  u32  RESERVED4[62];
-  vu32 IPR[15];
-} NVIC_TypeDef;
-
-typedef struct {
-  u8 NVIC_IRQChannel;
-  u8 NVIC_IRQChannelPreemptionPriority;
-  u8 NVIC_IRQChannelSubPriority;
-  USB_Bool NVIC_IRQChannelCmd; /* TRUE for enable */
-} NVIC_InitTypeDef;
-
-typedef struct {
-  vuc32 CPUID;
-  vu32 ICSR;
-  vu32 VTOR;
-  vu32 AIRCR;
-  vu32 SCR;
-  vu32 CCR;
-  vu32 SHPR[3];
-  vu32 SHCSR;
-  vu32 CFSR;
-  vu32 HFSR;
-  vu32 DFSR;
-  vu32 MMFAR;
-  vu32 BFAR;
-  vu32 AFSR;
-} SCB_TypeDef;
-
-
-void systemHardReset(void);
-
-void nvicInit        (NVIC_InitTypeDef*);
-void nvicDisableInterrupts(void);
-
-#if defined(__cplusplus)
-}
-#endif
-
-#endif
diff --git a/platform/stm32/libmaple/usb/usb_lib/usb_int.c b/platform/stm32/libmaple/usb/usb_lib/usb_int.c
deleted file mode 100644
index 61a989b..0000000
--- a/platform/stm32/libmaple/usb/usb_lib/usb_int.c
+++ /dev/null
@@ -1,192 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : usb_int.c
-* Author             : MCD Application Team
-* Version            : V2.2.1
-* Date               : 09/22/2008
-* Description        : Endpoint CTR (Low and High) interrupt's service routines
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Includes ------------------------------------------------------------------*/
-#include "usb_lib.h"
-
-/* Private typedef -----------------------------------------------------------*/
-/* Private define ------------------------------------------------------------*/
-/* Private macro -------------------------------------------------------------*/
-/* Private variables ---------------------------------------------------------*/
-u16 SaveRState;
-u16 SaveTState;
-
-/* Extern variables ----------------------------------------------------------*/
-extern void (*pEpInt_IN[7])(void);    /*  Handles IN  interrupts   */
-extern void (*pEpInt_OUT[7])(void);   /*  Handles OUT interrupts   */
-
-/* Private function prototypes -----------------------------------------------*/
-/* Private functions ---------------------------------------------------------*/
-
-/*******************************************************************************
-* Function Name  : CTR_LP.
-* Description    : Low priority Endpoint Correct Transfer interrupt's service
-*                  routine.
-* Input          : None.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CTR_LP(void)
-{
-  u32 wEPVal = 0;
-  /* stay in loop while pending ints */
-  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
-  {
-    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
-    /* extract highest priority endpoint number */
-    EPindex = (u8)(wIstr & ISTR_EP_ID);
-    if (EPindex == 0)
-    {
-      /* Decode and service control endpoint interrupt */
-      /* calling related service routine */
-      /* (Setup0_Process, In0_Process, Out0_Process) */
-
-      /* save RX & TX status */
-      /* and set both to NAK */
-      SaveRState = _GetEPRxStatus(ENDP0);
-      SaveTState = _GetEPTxStatus(ENDP0);
-      _SetEPRxStatus(ENDP0, EP_RX_NAK);
-      _SetEPTxStatus(ENDP0, EP_TX_NAK);
-
-
-      /* DIR bit = origin of the interrupt */
-
-      if ((wIstr & ISTR_DIR) == 0)
-      {
-        /* DIR = 0 */
-
-        /* DIR = 0      => IN  int */
-        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */
-
-
-        _ClearEP_CTR_TX(ENDP0);
-        In0_Process();
-
-           /* before terminate set Tx & Rx status */
-          _SetEPRxStatus(ENDP0, SaveRState);
-          _SetEPTxStatus(ENDP0, SaveTState);
-          return;
-      }
-      else
-      {
-        /* DIR = 1 */
-
-        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
-        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */
-
-        wEPVal = _GetENDPOINT(ENDP0);
-        if ((wEPVal & EP_CTR_TX) != 0)
-        {
-          _ClearEP_CTR_TX(ENDP0);
-          In0_Process();
-          /* before terminate set Tx & Rx status */
-          _SetEPRxStatus(ENDP0, SaveRState);
-          _SetEPTxStatus(ENDP0, SaveTState);
-          return;
-        }
-        else if ((wEPVal &EP_SETUP) != 0)
-        {
-          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
-          Setup0_Process();
-          /* before terminate set Tx & Rx status */
-          _SetEPRxStatus(ENDP0, SaveRState);
-          _SetEPTxStatus(ENDP0, SaveTState);
-          return;
-        }
-
-        else if ((wEPVal & EP_CTR_RX) != 0)
-        {
-          _ClearEP_CTR_RX(ENDP0);
-          Out0_Process();
-          /* before terminate set Tx & Rx status */
-          _SetEPRxStatus(ENDP0, SaveRState);
-          _SetEPTxStatus(ENDP0, SaveTState);
-          return;
-        }
-      }
-    }/* if(EPindex == 0) */
-    else
-    {
-      /* Decode and service non control endpoints interrupt  */
-
-      /* process related endpoint register */
-      wEPVal = _GetENDPOINT(EPindex);
-      if ((wEPVal & EP_CTR_RX) != 0)
-      {
-        /* clear int flag */
-        _ClearEP_CTR_RX(EPindex);
-
-        /* call OUT service function */
-        (*pEpInt_OUT[EPindex-1])();
-
-      } /* if((wEPVal & EP_CTR_RX) */
-
-      if ((wEPVal & EP_CTR_TX) != 0)
-      {
-        /* clear int flag */
-        _ClearEP_CTR_TX(EPindex);
-
-        /* call IN service function */
-        (*pEpInt_IN[EPindex-1])();
-      } /* if((wEPVal & EP_CTR_TX) != 0) */
-
-    }/* if(EPindex == 0) else */
-
-  }/* while(...) */
-}
-
-/*******************************************************************************
-* Function Name  : CTR_HP.
-* Description    : High Priority Endpoint Correct Transfer interrupt's service 
-*                  routine.
-* Input          : None.
-* Output         : None.
-* Return         : None.
-*******************************************************************************/
-void CTR_HP(void)
-{
-  u32 wEPVal = 0;
-
-  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
-  {
-    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
-    /* extract highest priority endpoint number */
-    EPindex = (u8)(wIstr & ISTR_EP_ID);
-    /* process related endpoint register */
-    wEPVal = _GetENDPOINT(EPindex);
-    if ((wEPVal & EP_CTR_RX) != 0)
-    {
-      /* clear int flag */
-      _ClearEP_CTR_RX(EPindex);
-
-      /* call OUT service function */
-      (*pEpInt_OUT[EPindex-1])();
-
-    } /* if((wEPVal & EP_CTR_RX) */
-    else if ((wEPVal & EP_CTR_TX) != 0)
-    {
-      /* clear int flag */
-      _ClearEP_CTR_TX(EPindex);
-
-      /* call IN service function */
-      (*pEpInt_IN[EPindex-1])();
-
-
-    } /* if((wEPVal & EP_CTR_TX) != 0) */
-
-  }/* while(...) */
-}
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
diff --git a/platform/stm32/libmaple/usb/usb_lib/usb_int.h b/platform/stm32/libmaple/usb/usb_lib/usb_int.h
deleted file mode 100644
index 5c14711..0000000
--- a/platform/stm32/libmaple/usb/usb_lib/usb_int.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
-* File Name          : usb_int.h
-* Author             : MCD Application Team
-* Version            : V2.2.1
-* Date               : 09/22/2008
-* Description        : Endpoint CTR (Low and High) interrupt's service routines
-*                      prototypes
-********************************************************************************
-* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
-* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
-* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
-* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
-* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
-* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
-*******************************************************************************/
-
-/* Define to prevent recursive inclusion -------------------------------------*/
-#ifndef __USB_INT_H
-#define __USB_INT_H
-
-/* Includes ------------------------------------------------------------------*/
-/* Exported types ------------------------------------------------------------*/
-/* Exported constants --------------------------------------------------------*/
-/* Exported macro ------------------------------------------------------------*/
-/* Exported functions ------------------------------------------------------- */
-#if defined(__cplusplus)
-extern "C" {
-#endif
-
-void CTR_LP(void);
-void CTR_HP(void);
-
-/* External variables --------------------------------------------------------*/
-
-#if defined(__cplusplus)
-}
-#endif
-
-#endif /* __USB_INT_H */
-
-/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
diff --git a/platform/stm32/libmaple/usb/usb_lib/usb_lib.h b/platform/stm32/libmaple/usb/usb_lib/usb_lib.h
index 4437b8d..85f94ab 100644
--- a/platform/stm32/libmaple/usb/usb_lib/usb_lib.h
+++ b/platform/stm32/libmaple/usb/usb_lib/usb_lib.h
@@ -24,7 +24,6 @@
 #include "usb_core.h"
 #include "usb_init.h"
 #include "usb_mem.h"
-#include "usb_int.h"
 
 /* Exported types ------------------------------------------------------------*/
 /* Exported constants --------------------------------------------------------*/
diff --git a/platform/stm32/rules.mk b/platform/stm32/rules.mk
index faa08f4..ce0b682 100644
--- a/platform/stm32/rules.mk
+++ b/platform/stm32/rules.mk
@@ -38,13 +38,11 @@ cSRCS_$(d) := \
 	stm32/libmaple/timer.c \
 	stm32/libmaple/usart.c \
 	stm32/libmaple/util.c \
-	stm32/libmaple/usb/descriptors.c \
 	stm32/libmaple/usb/usb.c \
-	stm32/libmaple/usb/usb_callbacks.c \
-	stm32/libmaple/usb/usb_hardware.c \
+	stm32/libmaple/usb/usb_reg_map.c \
+	stm32/libmaple/usb/usb_cdcacm.c \
 	stm32/libmaple/usb/usb_lib/usb_core.c \
 	stm32/libmaple/usb/usb_lib/usb_init.c \
-	stm32/libmaple/usb/usb_lib/usb_int.c \
 	stm32/libmaple/usb/usb_lib/usb_mem.c \
 	stm32/libmaple/usb/usb_lib/usb_regs.c
 sSRCS_$(d) := stm32/libmaple/exc.S
